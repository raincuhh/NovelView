🔄 Two Types of Export You Can Offer
📚 1. Export a Single Library
Done from a "Library options" screen

Export contents to a .zip or folder with:


Copy code
/{LibraryName}/
  ├── metadata.json          ← library name, desc, cover ref, etc.
  ├── books/
       ├── {BookTitle or ID}/
           ├── source.epub
           ├── cover.jpg
           └── info.json    ← bookInfo metadata
This is clean, organized, portable. On another device, user could just import this structure and you’d reconstruct the whole thing.

⚙️ 2. Export All Local Data
In app settings: "Export my data"

Same idea but across all local libraries (exclude type: sync libraries if needed):


Copy code
/MyAppExport_YYYY-MM-DD/
  ├── libraries/
      ├── localLibrary1/
      ├── localLibrary2/
  ├── userSettings.json
  ├── readingPrefs.json
Super clean. Feels like a backup. Also helps with support — "export and send me your data" is way easier than debugging in the dark.

✅ Bonus Benefits
Import flow becomes easy — drop a folder or zip, and you parse + rebuild.

Offline-first story gets stronger — users feel in control.

No vendor lock-in vibes — builds huge trust.

Keeps your sync layer optional and never forced.

💡 Smart Extra: "Export with Options"
You could even let users choose what to include:

 Include book covers

 Include parsed content

 Just export source EPUBs

 Export settings & prefs

Gives people more agency. And if someone just wants a backup of their raw EPUBs, it’s a one-tap solution.



sync:


✅ Your Sync Layer Is a Plugin — Perfect Mental Model
You're treating sync as optional, but when enabled, it integrates seamlessly and tracks shared state across devices. That’s exactly how sync should behave — graceful degradation when offline, full fidelity when online.

🧠 What You Need to Sync (Remote via PowerSync/Supabase)
If you sync only:

User Data

userProfile

userSettings

userReadingPrefs

premiumSubscription (optional but useful)

Library Data

libraries table (filtered: only type === "sync" goes to PowerSync)

Books

books table (tied to libraryId)

bookInfo (parsed metadata)

That’s literally all you need to fully reconstruct, rehydrate, and re-parse content locally. Everything else is either:

Parsed from the EPUB or source on demand

Stored in local-only per-book DBs

Inferred during app boot / book open / lazy-load

You don’t need to sync:

Chapters

Parsed content

Positions, highlights, or annotations

Covers (can be downloaded or pulled from EPUB or saved as local asset)

📂 Local Book Folder + DB Handles Everything Else
Your local structure:

pgsql
Copy code
/$localAppData/
  ├─ local.db              ← userProfile, settings, libraries (local-only)
  ├─ books/
      ├─ {bookId}/
          ├─ source.epub
          ├─ cover.jpg
          ├─ metadata.json      ← extra info not in bookInfo, if needed
          ├─ book.db            ← resources, chapters, positions, etc
          └─ resources/         ← parsed HTML, images, etc.
Let’s say you're offline. The moment you open a book, the app can:

Load metadata.json if it exists

Or parse the EPUB again (you have the file locally)

Then rehydrate all chapters, resources, and snippet data into book.db

🔁 Sync Flow Summary
Data	Stored In	Synced?	Why/Why Not?
userProfile	local.db / PowerSync	✅	Consistent identity
userSettings	local.db / PowerSync	✅	Cross-device app feel
userReadingPrefs	local.db / PowerSync	✅	Reader UI personalization
premiumSubscription	local.db / PowerSync	✅	Optional; for gating
libraries	local.db / PowerSync	✅ (if type is sync)	Split local vs sync state
books	local.db / PowerSync	✅ (only sync libs)	Entry point for all reading
bookInfo	local.db / PowerSync	✅	Author, summary, etc.
chapters, resources	book.db per book	❌	Parsed/inferred
positions, highlights	book.db per book	❌	Local-only experience
cover.jpg, source.epub	local file system	❌	Not needed remotely
🧩 Bonus Thought: "Smart Recovery"
Let’s say a user deletes app data or installs on a new device. With your synced data (libraries + books + metadata), the app can:

Recreate all sync-based libraries

Download source.epub from the fileUrl

Re-parse the content

Restore book content structure, book.db, etc.

That means your only download cost is the epub — everything else is computed. That's a crazy efficient sync model.

🚀 TL;DR
Yes, you’re absolutely right — syncing just:
user data + libraries + books + bookInfo is enough.
Everything else is derivable from local files, parsed content, or ephemeral UI state.

You're building something smart — minimal, portable, resilient. It’s modular, elegant, and highly maintainable. Sync is a power feature, but the core engine is still self-contained and functional.

Let me know if you want a quick ERD (entity-relational diagram) for both local and remote dbs, or a sample sync state tracker logic ✨
