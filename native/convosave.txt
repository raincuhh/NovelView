ğŸ”„ Two Types of Export You Can Offer
ğŸ“š 1. Export a Single Library
Done from a "Library options" screen

Export contents to a .zip or folder with:


Copy code
/{LibraryName}/
  â”œâ”€â”€ metadata.json          â† library name, desc, cover ref, etc.
  â”œâ”€â”€ books/
       â”œâ”€â”€ {BookTitle or ID}/
           â”œâ”€â”€ source.epub
           â”œâ”€â”€ cover.jpg
           â””â”€â”€ info.json    â† bookInfo metadata
This is clean, organized, portable. On another device, user could just import this structure and youâ€™d reconstruct the whole thing.

âš™ï¸ 2. Export All Local Data
In app settings: "Export my data"

Same idea but across all local libraries (exclude type: sync libraries if needed):


Copy code
/MyAppExport_YYYY-MM-DD/
  â”œâ”€â”€ libraries/
      â”œâ”€â”€ localLibrary1/
      â”œâ”€â”€ localLibrary2/
  â”œâ”€â”€ userSettings.json
  â”œâ”€â”€ readingPrefs.json
Super clean. Feels like a backup. Also helps with support â€” "export and send me your data" is way easier than debugging in the dark.

âœ… Bonus Benefits
Import flow becomes easy â€” drop a folder or zip, and you parse + rebuild.

Offline-first story gets stronger â€” users feel in control.

No vendor lock-in vibes â€” builds huge trust.

Keeps your sync layer optional and never forced.

ğŸ’¡ Smart Extra: "Export with Options"
You could even let users choose what to include:

 Include book covers

 Include parsed content

 Just export source EPUBs

 Export settings & prefs

Gives people more agency. And if someone just wants a backup of their raw EPUBs, itâ€™s a one-tap solution.



sync:


âœ… Your Sync Layer Is a Plugin â€” Perfect Mental Model
You're treating sync as optional, but when enabled, it integrates seamlessly and tracks shared state across devices. Thatâ€™s exactly how sync should behave â€” graceful degradation when offline, full fidelity when online.

ğŸ§  What You Need to Sync (Remote via PowerSync/Supabase)
If you sync only:

User Data

userProfile

userSettings

userReadingPrefs

premiumSubscription (optional but useful)

Library Data

libraries table (filtered: only type === "sync" goes to PowerSync)

Books

books table (tied to libraryId)

bookInfo (parsed metadata)

Thatâ€™s literally all you need to fully reconstruct, rehydrate, and re-parse content locally. Everything else is either:

Parsed from the EPUB or source on demand

Stored in local-only per-book DBs

Inferred during app boot / book open / lazy-load

You donâ€™t need to sync:

Chapters

Parsed content

Positions, highlights, or annotations

Covers (can be downloaded or pulled from EPUB or saved as local asset)

ğŸ“‚ Local Book Folder + DB Handles Everything Else
Your local structure:

pgsql
Copy code
/$localAppData/
  â”œâ”€ local.db              â† userProfile, settings, libraries (local-only)
  â”œâ”€ books/
      â”œâ”€ {bookId}/
          â”œâ”€ source.epub
          â”œâ”€ cover.jpg
          â”œâ”€ metadata.json      â† extra info not in bookInfo, if needed
          â”œâ”€ book.db            â† resources, chapters, positions, etc
          â””â”€ resources/         â† parsed HTML, images, etc.
Letâ€™s say you're offline. The moment you open a book, the app can:

Load metadata.json if it exists

Or parse the EPUB again (you have the file locally)

Then rehydrate all chapters, resources, and snippet data into book.db

ğŸ” Sync Flow Summary
Data	Stored In	Synced?	Why/Why Not?
userProfile	local.db / PowerSync	âœ…	Consistent identity
userSettings	local.db / PowerSync	âœ…	Cross-device app feel
userReadingPrefs	local.db / PowerSync	âœ…	Reader UI personalization
premiumSubscription	local.db / PowerSync	âœ…	Optional; for gating
libraries	local.db / PowerSync	âœ… (if type is sync)	Split local vs sync state
books	local.db / PowerSync	âœ… (only sync libs)	Entry point for all reading
bookInfo	local.db / PowerSync	âœ…	Author, summary, etc.
chapters, resources	book.db per book	âŒ	Parsed/inferred
positions, highlights	book.db per book	âŒ	Local-only experience
cover.jpg, source.epub	local file system	âŒ	Not needed remotely
ğŸ§© Bonus Thought: "Smart Recovery"
Letâ€™s say a user deletes app data or installs on a new device. With your synced data (libraries + books + metadata), the app can:

Recreate all sync-based libraries

Download source.epub from the fileUrl

Re-parse the content

Restore book content structure, book.db, etc.

That means your only download cost is the epub â€” everything else is computed. That's a crazy efficient sync model.

ğŸš€ TL;DR
Yes, youâ€™re absolutely right â€” syncing just:
user data + libraries + books + bookInfo is enough.
Everything else is derivable from local files, parsed content, or ephemeral UI state.

You're building something smart â€” minimal, portable, resilient. Itâ€™s modular, elegant, and highly maintainable. Sync is a power feature, but the core engine is still self-contained and functional.

Let me know if you want a quick ERD (entity-relational diagram) for both local and remote dbs, or a sample sync state tracker logic âœ¨
